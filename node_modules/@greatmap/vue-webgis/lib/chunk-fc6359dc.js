/*!
 * vue-webgis v0.7.3
 */

import 'core-js/modules/es6.function.name';
import { e as errorMessage } from './chunk-8430f437.js';
import { G as GISEvent } from './chunk-2f41c7fa.js';
import { a as _classCallCheck, b as _defineProperty, _ as _createClass } from './chunk-82f2c815.js';
import { _ as _inherits, a as _possibleConstructorReturn, b as _getPrototypeOf, c as _assertThisInitialized } from './chunk-537b1685.js';
import { S as SERVER_CONFIG } from './chunk-bc626433.js';
import { r as request, c as checkValidArray } from './chunk-81d749a9.js';

var superDataPath = SERVER_CONFIG.superDataPath;
function createAnalysisService(name) {
  return request({
    url: "/portal/sharing/rest/content/users/admin/createService",
    method: 'post',
    data: {
      f: 'json',
      createParameters: JSON.stringify({
        currentVersion: 10.2,
        serviceDescription: '',
        hasVersionedData: false,
        supportsDisconnectedEditing: false,
        hasStaticData: true,
        maxRecordCount: 2000,
        supportedQueryFormats: 'JSON',
        capabilities: 'Query',
        description: '',
        copyrightText: '',
        allowGeometryUpdates: false,
        syncEnabled: false,
        editorTrackingInfo: {
          enableEditorTracking: false,
          enableOwnershipAccessControl: false,
          allowOthersToUpdate: true,
          allowOthersToDelete: true
        },
        xssPreventionInfo: {
          xssPreventionEnabled: true,
          xssPreventionRule: 'InputOnly',
          xssInputRule: 'rejectInvalid'
        },
        tables: [],
        name: name,
        options: {
          dataSourceType: 'spatiotemporal'
        }
      }),
      outputType: 'featureService'
    },
    analysisToken: true
  });
}
function createBuffersAnalysis(_ref) {
  var serviceUrl = _ref.serviceUrl,
      serviceId = _ref.serviceId,
      extent = _ref.extent,
      wkid = _ref.wkid,
      distance = _ref.distance,
      name = _ref.name,
      serviceCode = _ref.serviceCode;
  return request({
    url: "/server/rest/services/System/GeoAnalyticsTools/GPServer/CreateBuffers/submitJob",
    method: 'post',
    data: {
      f: 'json',
      inputLayer: JSON.stringify({
        url: "".concat(SERVER_CONFIG.arcgisOrigin, "/server/rest/services/DataStoreCatalogs/").concat(superDataPath, "/BigDataCatalogServer/").concat(serviceCode),
        name: "".concat(superDataPath, "-").concat(serviceCode)
      }),
      distance: distance || 10,
      distanceUnit: 'Meters',
      method: 'Geodesic',
      dissolveOption: 'None',
      OutputName: JSON.stringify({
        serviceProperties: {
          name: name,
          serviceUrl: serviceUrl,
          itemProperties: {
            itemId: serviceId
          }
        }
      }),
      context: JSON.stringify({
        extent: {
          xmin: extent[0],
          ymin: extent[1],
          xmax: extent[2],
          ymax: extent[3],
          spatialReference: {
            wkid: wkid,
            latestWkid: wkid
          }
        },
        outSR: {
          spatialReference: {
            wkid: wkid
          }
        }
      })
    },
    analysisToken: true
  });
}
function createOverlayAnalysis(_ref2) {
  var serviceUrl = _ref2.serviceUrl,
      serviceId = _ref2.serviceId,
      name = _ref2.name,
      inputLayer = _ref2.inputLayer,
      overlayLayer = _ref2.overlayLayer,
      _ref2$overlayType = _ref2.overlayType,
      overlayType = _ref2$overlayType === void 0 ? 'Intersect' : _ref2$overlayType;
  return request({
    url: "/server/rest/services/System/GeoAnalyticsTools/GPServer/OverlayLayers/submitJob",
    method: 'post',
    data: {
      f: 'json',
      inputLayer: JSON.stringify(inputLayer),
      overlayLayer: JSON.stringify(overlayLayer),
      overlayType: overlayType,
      dissolveOption: 'None',
      OutputName: JSON.stringify({
        serviceProperties: {
          name: name,
          serviceUrl: serviceUrl,
          itemProperties: {
            itemId: serviceId
          }
        }
      })
    },
    analysisToken: true
  });
}
function createSummaryAnalysis(_ref3) {
  var serviceUrl = _ref3.serviceUrl,
      serviceId = _ref3.serviceId,
      name = _ref3.name,
      inputLayer = _ref3.inputLayer;
  return request({
    url: '/server/rest/services/System/GeoAnalyticsTools/getAnalysisProgress/SummarizeAttributes/submitJob',
    method: 'post',
    data: {
      f: 'json',
      inputLayer: JSON.stringify(inputLayer),
      fields: 'DLBM_overlay,DLMC_overlay,ZLDWDM_overlay,ZLDWMC_overlay',
      summaryFields: JSON.stringify([{
        statisticType: 'SUM',
        onStatisticField: 'TBDLMJ_overlay'
      }]),
      OutputName: JSON.stringify({
        serviceProperties: {
          name: name,
          serviceUrl: serviceUrl,
          itemProperties: {
            itemId: serviceId
          }
        }
      })
    },
    analysisToken: true
  });
}
function getAnalysisProgress(name, id) {
  return request({
    url: "/server/rest/services/System/GeoAnalyticsTools/GPServer/".concat(name, "/jobs/").concat(id),
    params: {
      f: 'json'
    },
    analysisToken: true
  });
}
function getAnalysisResult(name, id) {
  return request({
    url: "/server/rest/services/Hosted/".concat(name, "/FeatureServer/0/query"),
    method: 'post',
    data: {
      where: '1=1',
      returnGeometry: true,
      outFields: '*',
      outSR: id,
      f: 'json',
      objectIds: '',
      returnDistinctValues: '',
      orderByFields: ''
    }
  });
}

var BaseAnalysis =
/*#__PURE__*/
function (_GISEvent) {
  _inherits(BaseAnalysis, _GISEvent);

  function BaseAnalysis(map) {
    var _this2;

    _classCallCheck(this, BaseAnalysis);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BaseAnalysis).call(this, 'next'));

    _defineProperty(_assertThisInitialized(_this2), "_intervalTime", 1500);

    _defineProperty(_assertThisInitialized(_this2), "_vectorSource", void 0);

    _defineProperty(_assertThisInitialized(_this2), "_map", void 0);

    _this2._vectorSource = map.vectorSource;
    _this2._map = map;
    return _this2;
  }

  _createClass(BaseAnalysis, [{
    key: "getProgress",
    value: function getProgress(name, id) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var _this = _this3;

        (function polling() {
          getAnalysisProgress(name, id).then(function (res) {
            var status = res ? res.jobStatus : '';

            if (status === 'esriJobSucceeded') {
              resolve(res);
            } else if (status !== 'esriJobFailed') {
              setTimeout(function () {
                return polling();
              }, _this._intervalTime);

              if (checkValidArray(res.messages)) {
                _this.dispatch('next', res.messages && res.messages.pop());
              }
            } else {
              errorMessage(res || res.message);
              reject(res);
            }
          }, function (error) {
            errorMessage(error || error.message);
            reject(error);
          });
        })();
      });
    }
  }]);

  return BaseAnalysis;
}(GISEvent);

export { BaseAnalysis as B, createSummaryAnalysis as a, createAnalysisService as b, createOverlayAnalysis as c, createBuffersAnalysis as d, getAnalysisResult as g };
//# sourceMappingURL=chunk-fc6359dc.js.map
