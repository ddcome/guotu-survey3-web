/*!
 * vue-webgis v0.7.3
 */

import 'vue';
import 'core-js/modules/es6.function.name';
import 'core-js/modules/es7.array.includes';
import 'core-js/modules/es6.string.includes';
import 'core-js/modules/es6.array.find';
import 'core-js/modules/web.dom.iterable';
import 'core-js/modules/es6.object.keys';
import './chunk-8430f437.js';
import 'core-js/modules/es6.string.iterator';
import 'core-js/library/fn/object/get-own-property-descriptor';
import { _ as _objectSpread } from './chunk-786165bb.js';
import 'core-js/library/fn/object/get-own-property-symbols';
import 'core-js/library/fn/object/keys';
import 'core-js/library/fn/object/define-property';
import { _ as _createClass, a as _classCallCheck, b as _defineProperty } from './chunk-82f2c815.js';
import { S as SERVER_CONFIG } from './chunk-bc626433.js';
import 'axios';
import 'qs/lib/stringify';
import { r as request, c as checkValidArray } from './chunk-81d749a9.js';

function getIntersectGeometry(sr, geometries, geometry) {
  return request({
    url: SERVER_CONFIG.arcgisRestService + 'Utilities/Geometry/GeometryServer/intersect',
    method: 'post',
    data: {
      f: 'json',
      sr: sr,
      geometry: geometry,
      geometries: geometries
    },
    analysisToken: true
  });
}

var IntersectAnalysis =
/*#__PURE__*/
function () {
  function IntersectAnalysis(map) {
    _classCallCheck(this, IntersectAnalysis);

    _defineProperty(this, "_map", void 0);

    this._map = map;
  }

  _createClass(IntersectAnalysis, [{
    key: "doAnalysis",
    value: function doAnalysis(layerID, geometry) {
      var _this = this;

      var params = this._map.getLayerInfoParams(layerID);

      if (params) {
        return this._map.getLayerInfo(params).then(function (res) {
          if (!checkValidArray(res.features)) {
            return Promise.resolve([]);
          }

          var sourceFeaturesData = res;
          var geometries = {
            geometries: res.features.map(function (item) {
              return item.geometry;
            }),
            geometryType: res.geometryType
          };

          var geometryObject = _this._map.formatGeometryObject(geometry);

          return getIntersectGeometry(_this._map.mapConfig.wkid, JSON.stringify(geometries), JSON.stringify(geometryObject)).then(function (res) {
            var resultData = sourceFeaturesData.features.map(function (item) {
              return _objectSpread({}, item.attributes, {
                meta: {
                  intersectSizeStr: '',
                  intersectSizeNum: 0
                }
              });
            });

            if (checkValidArray(res.geometries)) {
              var features = _this._map.renderFeatureData({
                features: res.geometries.map(function (item) {
                  return {
                    geometry: item
                  };
                })
              });

              features.forEach(function (item, index) {
                var area = _this._map.formatGeometrySize(item.getGeometry());

                resultData[index].meta = {
                  intersectSizeStr: area.str,
                  intersectSizeNum: area.num
                };
              });
            }

            return resultData;
          });
        });
      } else {
        return Promise.resolve([]);
      }
    }
  }, {
    key: "doAnalysisMulti",
    value: function doAnalysisMulti(layerIDs, geometry) {
      var _this2 = this;

      return Promise.all(layerIDs.map(function (item) {
        return _this2.doAnalysis(item, geometry);
      }));
    }
  }]);

  return IntersectAnalysis;
}();

export default IntersectAnalysis;
//# sourceMappingURL=intersect-analysis-760289f0.js.map
