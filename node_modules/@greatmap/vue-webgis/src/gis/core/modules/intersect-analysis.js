import { getIntersectGeometry } from '../../api/modules/conflict-detection';
import { checkValidArray } from '../../../utils/check-array';

export default class IntersectAnalysis {
  _map;

  constructor(map) {
    this._map = map;
  }

  /**
   * 开始分析
   * @param {String} layerID
   * @param {Number[]|Geometry} geometry
   * @return {Promise<Object|null[]>}
   */
  doAnalysis(layerID, geometry) {
    const params = this._map.getLayerInfoParams(layerID);
    if (params) {
      // 获取图层属性
      return this._map.getLayerInfo(params).then((res) => {
        if (!checkValidArray(res.features)) {
          return Promise.resolve([]);
        }

        // 暂存原始的数据
        const sourceFeaturesData = res;
        const geometries = {
          geometries: res.features.map((item) => item.geometry),
          geometryType: res.geometryType
        };
        const geometryObject = this._map.formatGeometryObject(geometry);

        return getIntersectGeometry(
          this._map.mapConfig.wkid,
          JSON.stringify(geometries),
          JSON.stringify(geometryObject)
        ).then((res) => {
          // 先解析所有的 features（图层所有的，包括未相交的）
          const resultData = sourceFeaturesData.features.map((item) => {
            return {
              ...item.attributes,
              meta: {
                intersectSizeStr: '',
                intersectSizeNum: 0
              }
            };
          });

          // 解析相交后的数据，如果相交则给 meta 赋值
          if (checkValidArray(res.geometries)) {
            const features = this._map.renderFeatureData({
              features: res.geometries.map((item) => ({
                geometry: item
              }))
            });
            features.forEach((item, index) => {
              const area = this._map.formatGeometrySize(item.getGeometry());
              resultData[index].meta = {
                intersectSizeStr: area.str,
                intersectSizeNum: area.num
              };
            });
          }

          return resultData;
        });
      });
    } else {
      return Promise.resolve([]);
    }
  }

  /**
   * 开始分析（批量），返回二维数组（对应传入的 layerIDs 下标）
   * @param {Array<String>} layerIDs
   * @param {Number[]|Geometry} geometry
   * @return {Promise<(Object|null[])[]>}
   */
  doAnalysisMulti(layerIDs, geometry) {
    return Promise.all(layerIDs.map((item) => this.doAnalysis(item, geometry)));
  }
}
