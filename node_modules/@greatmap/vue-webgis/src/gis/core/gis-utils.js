/**
 * gis 工具类
 */
import Style from 'ol/style/Style';
import Fill from 'ol/style/Fill';
import Stroke from 'ol/style/Stroke';
import EsriJSON from 'ol/format/EsriJSON';
import { getArea, getLength } from 'ol/sphere';

import saveCanvas from '../utils/export-map';
import { getControls } from './controls';
import { getServiceDetail } from '../api/service';
import paramToArray from '../utils/param-to-array';
import { mergeConfig } from '../../utils/update-config';
import { warnMessage } from '../../utils/error-handler';
import { formatObjectSimple } from '../utils/format-object';
import { checkValidArray } from '../../utils/check-array';
import { formatAreaToString, formatLengthToStr } from '../utils/format-number';

/**
 * @typedef {module:ol/geom/Point|module:ol/geom/LineString|module:ol/geom/Polygon} Geometry
 */

/**
 * /rest/service/xxx/MapServer/x/query 接口的请求参数
 * @typedef {object} LayerQueryParams
 * @property {string} serviceCode 服务地址，例如：X510183TDXZG2017XZQ
 * @property {string} layerId 图层的 id，例如：0
 * @property {string} epsgNum 参考系，例如：4499
 * @property {number[]|Geometry} extent 范围，例如：[12, 122, 12, 12] 或者 geometry 对象
 * @property {string} [where] 查询语句，例如：BSM='123'
 * @property {boolean} [returnGeometry=true] 是否返回 geometry 数据
 * @property {string} [outFields=*] 输出 fields，例如：'BSM,DLTB'
 */

/**
 * @typedef {import("ol/Feature.js")} Feature
 */

/**
 * @typedef {Feature|import("ol/render/Feature")} FeatureLike
 */

/**
 * @typedef {Object} FeatureData
 * @property {FeatureLike[]} features
 * @property {Object[]} fields
 */

/**
 * Map 的混入类
 * @mixin GISUtils
 */
export default class GISUtils {
  // EsriJSON
  formatEsriJSON = new EsriJSON();

  // 当前地图元素样式
  _mapCursorStyle;
  _defaultCursor = 'default';
  _updateSizeTimeId = 0;
  _selectInteractionState = true;

  constructor(olMap) {
    this._mapCursorStyle = olMap.getTarget().style;
  }

  /**
   * 更新地图尺寸
   * @description 使用 `requestAnimationFrame` 进行动画优化
   * @param {Number} duration 持续时间，用于动画中进行过渡式更新大小
   */
  updateSize(duration = 0) {
    const olMap = this.olMap;
    if (this._updateSizeTimeId) cancelAnimationFrame(this._updateSizeTimeId);
    this._updateSizeTimeId = setTimeout(() => {
      this._updateSizeTimeId = 0;
    }, duration);
    const animationCallback = () => {
      if (this._updateSizeTimeId) {
        olMap.updateSize();
        requestAnimationFrame(animationCallback);
      }
    };
    requestAnimationFrame(animationCallback);
  }

  /**
   * 导出 image
   */
  exportImage() {
    this.olMap.once('rendercomplete', (event) =>
      saveCanvas(event.context.canvas)
    );
    this.olMap.renderSync();
  }

  /**
   * 切换光标样式
   * @param {String} type
   * @private
   */
  toggleCursorStyle(type = this._defaultCursor) {
    this._defaultCursor = this._mapCursorStyle.cursor;
    this._mapCursorStyle.cursor = type;
  }

  /**
   * 切换地图控件
   * @param {Boolean} state
   * @param {Array?} controlsName
   */
  toggleControls(state, controlsName) {
    if (state) {
      const controls = getControls(controlsName);
      controls.forEach((item, index) => {
        this.olMap.addControl(item);
        this.controls[controlsName[index]] = item;
      });
    } else {
      if (!controlsName || !controlsName.length) {
        controlsName = Object.keys(this.controls);
      }
      controlsName.forEach((item) => {
        if (this.controls.hasOwnProperty(item)) {
          this.olMap.removeControl(this.controls[item]);
          delete this.controls[item];
        }
      });
    }
  }

  /**
   * 切换要去选取的状态
   * @param state
   */
  toggleSelectInteraction(state = !this._selectInteractionState) {
    this._selectInteractionState = state;
    this.selectInteraction.setActive(state);
  }

  /**
   * 获取图层信息
   * @param {LayerQueryParams} param
   * @return {Promise<FeatureData>}
   */
  getLayerInfo(param) {
    // extent 转换为 geometry/geometryType
    const newParam = { ...param };
    const { geometry, geometryType } = this.formatGeometryObject(
      newParam.extent
    );

    newParam.geometry = JSON.stringify(geometry);
    newParam.geometryType = geometryType;
    delete newParam.extent;

    return getServiceDetail(newParam);
  }

  /**
   * 获取图层的详情请求参数
   * @param {String} layerId 图层ID
   * @param {Object} elseParams 其他参数
   * @return {{extent: *, layerId: *, serviceCode: *, epsgNum: *}|null}
   */
  getLayerInfoParams(layerId, elseParams = {}) {
    const node = this.treeLayers.find((item) => item.id === layerId);
    if (node) {
      const nodeConfig = node.config;
      const nodeConfigGroup = node.configGroup;
      return {
        serviceCode: nodeConfig.serviceCode,
        layerId: nodeConfig.serverId,
        epsgNum: nodeConfigGroup.wkid,
        extent: nodeConfigGroup.extent,
        ...elseParams
      };
    } else {
      warnMessage(`未找到该图层 ${layerId}`);
      return null;
    }
  }

  /**
   * 获取图层字段
   * @param {String} layerId 图层ID
   * @return {Promise<{label: *, value: *}[]>}
   */
  getLayerField(layerId) {
    return this.getLayerInfo(
      this.getLayerInfoParams(layerId, { returnGeometry: false })
    ).then((res) => {
      return res.fields
        .map((item) => {
          return {
            value: item.name,
            label: item.alias
          };
        })
        .filter((res) => res.value);
    });
  }

  /**
   * 获取图层字段值
   * @param {String} layerId 图层ID
   * @param {String} field 字段名称
   * @return {Promise<{label: *, value: *}[]>}
   */
  getLayerFieldValue(layerId, field) {
    return this.getLayerInfo(
      this.getLayerInfoParams(layerId, {
        outFields: field,
        returnGeometry: false
      })
    ).then((res) => {
      const result = new Set();
      const features = res.features;
      let fieldValue;
      features.forEach(
        /**@type {Object<attributes>} item */ (item) => {
          fieldValue = String(item.attributes[field]).trim();
          fieldValue && result.add(fieldValue);
        }
      );
      return Array.from(result).map((item) => ({ value: item, label: item }));
    });
  }

  /**
   * 解析要素
   * @param {FeatureData} featureData
   * @return {FeatureLike[]}
   */
  resolveFeatureData(featureData) {
    return /**@type {FeatureLike[]} */ this.formatEsriJSON.readFeatures(
      featureData
    );
  }

  /**
   * 渲染要素数据
   * @param {FeatureData} featureData 要素数据
   * @return {FeatureLike|FeatureLike[]}
   */
  renderFeatureData(featureData) {
    const features = this.resolveFeatureData(featureData);
    this.addFeature(features);

    return features;
  }

  /**
   * 添加要素
   * @param {Feature|Feature[]} feature
   */
  addFeature(feature) {
    const vectorSource = this.vectorSource;
    feature = paramToArray(feature);
    feature.forEach((item) => {
      if (item && !vectorSource.hasFeature(item)) {
        vectorSource.addFeature(item);
      }
    });
  }

  /**
   * 移除 feature
   * @param {Feature|Feature[]} feature
   */
  removeFeature(feature) {
    const vectorSource = this.vectorSource;
    feature = paramToArray(feature);
    feature.forEach((item) => {
      if (item && vectorSource.hasFeature(item)) {
        vectorSource.removeFeature(item);
      }
    });
  }

  /**
   * 聚焦 feature
   * @param {Feature} feature
   * @return {Feature}
   */
  focusFeature(feature) {
    this.setFeatureStyle(feature);
    this.addFeature(feature);
    this.interactions.zoom.toFeatures([feature]);
    return feature;
  }

  /**
   * 查询要素（在当前展示的图层上查询）
   *
   * @param {object} [params] 查询参数
   * @property {number[]} [extent] 范围
   * @property {string} [where] SQL语句
   * @property {string[]} [layerIds] 可查询的图层ID
   * @return {Promise<{data: Array, features: Array}>}
   */
  searchFeature(params = {}) {
    const { layerIds } = params;
    let filterCallback = (layer) => layer.checked;
    if (checkValidArray(layerIds)) {
      this.checkChange(layerIds, true);
      filterCallback = (layer) => layerIds.includes(layer.id);
    }
    let config, configGroup;
    const promiseArr = this.treeLayers.filter(filterCallback).map((layer) => {
      config = layer.config;
      configGroup = layer.configGroup;
      return this.getLayerInfo({
        serviceCode: config.serviceCode,
        layerId: config.serverId,
        epsgNum: configGroup.wkid,
        extent: params.extent || configGroup.extent,
        where: params.where
      }).then((res) => {
        if (res && !res.error) {
          const features = this.resolveFeatureData(res);
          let properties, BSM;
          return {
            id: layer.id,
            name: layer.name,
            children: features.map((feature) => {
              properties = formatObjectSimple(feature.getProperties());
              BSM = properties.BSM;
              // 兼容数据格式 - start
              if (!BSM && BSM !== 0) {
                warnMessage('找不到该数据 BSM 值，将使用 OBJECTID', properties);
                BSM = properties.BSM = properties.OBJECTID;
                feature.set('BSM', BSM);
              }
              // 兼容数据格式 - end
              return {
                id: BSM,
                name: BSM,
                properties
              };
            }),
            features
          };
        } else {
          return Promise.reject(res);
        }
      });
    });
    return Promise.all(promiseArr).then(
      /**@type {Array} data */ (data) => {
        let features = [];
        data = data.filter((item) => checkValidArray(item.children));
        if (data.length) {
          features = data.reduce(
            (prev, next) => [...prev, ...next.features],
            []
          );
          this.clearFeature();
          this.addFeature(features);
          this.interactions.zoom.toFeatures(features);
        }
        return { features, data };
      },
      (error) => {
        return Promise.reject(error);
      }
    );
  }

  /**
   * 选中要素
   * @param {Feature|Feature[]} feature 要素对象或集合
   */
  selectFeature(feature) {
    this.clearSelectFeature();
    const features = paramToArray(feature);
    features.forEach((item) => this.selectedFeatures.push(item));
  }

  /**
   * 设置要素样式
   * @param {Feature|Feature[]} feature
   * @param {{fillStyle, strokeStyle}} [options]
   * @property {Object} [fillStyle] 填充样式，参考 ol/style/Style 配置
   * @property {Object} [strokeStyle] 线条样式，参考 ol/style/Stroke 配置
   */
  setFeatureStyle(feature, options = {}) {
    const features = paramToArray(feature);
    mergeConfig(
      {
        fillStyle: {
          color: 'rgba(255,255,255,0.7)'
        },
        strokeStyle: {
          color: '#3399CC',
          width: 3
        }
      },
      options
    );
    features.forEach((feature) =>
      feature.setStyle(
        new Style({
          fill: new Fill(options.fillStyle),
          stroke: new Stroke(options.strokeStyle)
        })
      )
    );
  }

  // 清理选中要素
  clearSelectFeature() {
    this.selectedFeatures.clear();
  }

  /**
   * 清理要素
   */
  clearFeature() {
    this.clearSelectFeature();
    this.vectorSource.clear();
  }

  /**
   * 清理地图上的元素
   * 1. 清理覆盖层
   * 2. 清理要素
   */
  clear() {
    // remove overlay
    this.olMap.getOverlays().clear();

    // remove feature
    this.clearFeature();

    // emit event
    this.eventHub.dispatch('clear');
  }

  /**
   * 获取几何范围
   * @param {Number[]|Geometry} geometryLike
   */
  formatGeometryObject(geometryLike) {
    let geometry = {};
    let geometryType = '';
    if (Array.isArray(geometryLike)) {
      geometryType = 'esriGeometryEnvelope';
      geometry = {
        xmin: geometryLike[0],
        ymin: geometryLike[1],
        xmax: geometryLike[2],
        ymax: geometryLike[3]
      };
    } else {
      const type = geometryLike.getType();
      geometryType =
        type === 'Polygon'
          ? 'esriGeometryPolygon'
          : type === 'Point'
          ? 'esriGeometryPoint'
          : 'esriGeometryPolyline';
      geometry = this.formatEsriJSON.writeGeometryObject(geometryLike);
    }

    geometry.spatialReference = {
      wkid: this.mapConfig.wkid
    };

    return {
      geometryType,
      geometry
    };
  }

  /**
   * 格式化几何图形的大小
   * @param {Polygon|LineString} geometry
   * @return {{str: String, num: Number}}
   */
  formatGeometrySize(geometry) {
    const type = geometry.getType();
    const params = { projection: this.mapConfig.epsg };
    let str = '',
      num = 0;
    switch (type) {
      case 'Polygon':
        num = getArea(geometry, params);
        str = formatAreaToString(num);
        break;
      case 'LineString':
        num = getLength(geometry, params);
        str = formatLengthToStr(num);
        break;
      default:
    }
    return { str, num };
  }
}
